import { createClient } from "@supabase/supabase-js"
import { NextResponse } from "next/server"

export async function POST(request, { params }) {
  try {
    console.log("[v0] Tournament seeding request for tournament:", params.id)

    const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY)

    const { seedingType, userId } = await request.json()
    console.log("[v0] Seeding type:", seedingType, "User ID:", userId)

    if (!userId) {
      return NextResponse.json({ error: "User ID required" }, { status: 400 })
    }

    // Get tournament and verify ownership
    const { data: tournament, error: tournamentError } = await supabase
      .from("tournaments")
      .select("*")
      .eq("id", params.id)
      .eq("organizer_id", userId)
      .single()

    if (tournamentError || !tournament) {
      console.log("[v0] Tournament not found or not owned by user:", tournamentError)
      return NextResponse.json({ error: "Tournament not found or unauthorized" }, { status: 404 })
    }

    // Check if bracket is already generated by looking at existing matches
    const { data: existingMatches } = await supabase
      .from("matches")
      .select("id")
      .eq("tournament_id", params.id)
      .limit(1)

    if (existingMatches && existingMatches.length > 0) {
      const { error: deleteError } = await supabase.from("matches").delete().eq("tournament_id", params.id)

      if (deleteError) {
        console.log("[v0] Error deleting existing matches:", deleteError)
        return NextResponse.json({ error: "Failed to clear existing bracket" }, { status: 500 })
      }
    }

    // Get tournament participants
    const { data: participants, error: participantsError } = await supabase
      .from("tournament_participants")
      .select(`
        user_id,
        profiles:user_id (
          id,
          username,
          display_name
        )
      `)
      .eq("tournament_id", params.id)

    if (participantsError) {
      console.log("[v0] Error fetching participants:", participantsError)
      return NextResponse.json({ error: "Failed to fetch participants" }, { status: 500 })
    }

    if (participants.length < 2) {
      return NextResponse.json({ error: "Need at least 2 participants to generate bracket" }, { status: 400 })
    }

    console.log("[v0] Found participants:", participants.length)

    // Randomly shuffle participants for seeding
    const shuffledParticipants = [...participants].sort(() => Math.random() - 0.5)

    // Generate matches for single elimination bracket
    const totalRounds = Math.ceil(Math.log2(shuffledParticipants.length))
    const matches = []
    let matchNumber = 1

    // First round matches
    for (let i = 0; i < shuffledParticipants.length; i += 2) {
      const player1 = shuffledParticipants[i]
      const player2 = shuffledParticipants[i + 1] || null

      matches.push({
        tournament_id: params.id,
        round: 1,
        match_number: matchNumber++,
        player1_id: player1.user_id,
        player2_id: player2?.user_id || null,
        status: player2 ? "pending" : "completed", // Bye match if odd number of players
        winner_id: player2 ? null : player1.user_id,
        created_at: new Date().toISOString(),
      })
    }

    // Generate placeholder matches for subsequent rounds
    let previousRoundMatches = matches.length
    for (let round = 2; round <= totalRounds; round++) {
      const roundMatches = Math.ceil(previousRoundMatches / 2)
      for (let i = 0; i < roundMatches; i++) {
        matches.push({
          tournament_id: params.id,
          round: round,
          match_number: matchNumber++,
          player1_id: null,
          player2_id: null,
          status: "waiting",
          created_at: new Date().toISOString(),
        })
      }
      previousRoundMatches = roundMatches
    }

    console.log("[v0] Generated matches:", matches.length)

    // Insert matches into database
    const { data: insertedMatches, error: matchesError } = await supabase.from("matches").insert(matches).select()

    if (matchesError) {
      console.log("[v0] Error inserting matches:", matchesError)
      return NextResponse.json({ error: "Failed to create matches" }, { status: 500 })
    }

    const { error: updateError } = await supabase
      .from("tournaments")
      .update({
        status: "ongoing",
      })
      .eq("id", params.id)

    if (updateError) {
      console.log("[v0] Error updating tournament:", updateError)
      return NextResponse.json({ error: "Failed to update tournament" }, { status: 500 })
    }

    console.log("[v0] Tournament seeded successfully")

    return NextResponse.json({
      success: true,
      message: "Tournament bracket generated successfully",
      matches: insertedMatches.length,
      rounds: totalRounds,
    })
  } catch (error) {
    console.error("[v0] Tournament seeding error:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}
